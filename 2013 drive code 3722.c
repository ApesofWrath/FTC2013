#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touch,          sensorI2CMuxController)
#pragma config(Sensor, S3,     infared,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touchUp,        sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     leftBack,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightBack,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightFront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     liftMotor1,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_2,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c" //Include file to "handle" the Bluetooth messages.

// #defines for magical values
#define DIVISOR        1.28 //=((1/1)128)/100 = 1/1 power
#define DIVISOR_LIFT 1.28 //=((1/1)128)/100 = 1/1 power
#define MARGIN        4

// #defines an expression to bitmask for the arcade and tank buttons
// button 5, joy 1
#define ARCADE        (joystick.joy1_Buttons & 0b01010000)
// button 6, joy 1
#define TANK                (joystick.joy1_Buttons & 0b10100000)
// button 5, joy 2
#define OPEN (joystick.joy2_Buttons & 0b01010000)
// button 6, joy 2
#define CLOSE (joystick.joy2_Buttons & 0b10100000)
//invert the encoder
#define LIFT_ENCODER_READ (-nMotorEncoder[liftMotor1])

// keeps the value a between b and c
#define CONSTRAIN(a, b, c) ( ((a)<(b)) ? (b) : ( ((a)>(c)) ? (c) : (a)) )

#define MAXARM 3000

#define MINARM 10

// variable to track arcade and tank modes
bool tank = true;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to initialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//these lines make sure the motors are stopped when the robot is turned on
	motor[rightBack] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[leftFront] = 0;
	nMotorEncoder[liftMotor1] = 0;
	//servo[servo1] = 0;
	servo[servo1] = 255;
	servoChangeRate[servo1] = 10;
	return;
}


void drive()
{
	// retrieves joystick values
	getJoystickSettings(joystick);
	// switches between arcade and tank
	if (ARCADE)
	{
		tank = false;
	}
	if (TANK)
	{
		tank = true;
	}
	// tank driving
	if (tank)
	{
		// translates joystick values from 128 to -127 to motor speeds
		float y1 = (float)(joystick.joy1_y1) / DIVISOR;
		float y2 = -(float)(joystick.joy1_y2) / DIVISOR;
		// wheels are still when desired
	y1 = (abs(y1) - MARGIN < MARGIN) ? 0 : y1;
	y2 = (abs(y2) - MARGIN < MARGIN) ? 0 : y2;
		// sets motors
		motor[leftBack] = y1;
		motor[leftFront] = y1;
		motor[rightBack] = y2;
		motor[rightFront] = y2;
	}
	// arcade mode
	else
	{
		//translates joystick values to motor speeds
		float y = (float)(joystick.joy1_y2) / DIVISOR;
		float x = (float)(joystick.joy1_x2) / DIVISOR;
		// wheels are still when desired
	y = (abs(y) - MARGIN < MARGIN) ? 0 : y;
	x = (abs(x) - MARGIN < MARGIN) ? 0 : x;
		// calculates arcade values
		float left = CONSTRAIN(y + x, -128 / DIVISOR, 128 / DIVISOR);
		float right = -CONSTRAIN(y - x, -128 / DIVISOR, 128 / DIVISOR);
		// sets motors
		motor[leftBack] = left;
		motor[leftFront] = left;
		motor[rightBack] = right;
		motor[rightFront] = right;
	}

}

//for the arm
void arm()
{
	// retrieves joystick settings
	getJoystickSettings(joystick);
	//translates joystick values to motor values
	float y = (float) (joystick.joy2_y1) / DIVISOR_LIFT;
	y *= -1;

	string s;
	sprintf (s,"%d",LIFT_ENCODER_READ);
	nxtDisplayCenteredTextLine(1, s);

	sprintf (s,"%d",joystick.joy2_Buttons);
	nxtDisplayCenteredTextLine(2, s);
#if 0
	if ( y > 0 )
	{

		if (LIFT_ENCODER_READ > MAXARM)
		{
			y = 0;
		}//maxarm
	}// y>0

	if (y < 0 )
	{
		if (LIFT_ENCODER_READ < MINARM)
		{
			y = 0;
		}//minarm
	}//y<0
#endif // ends the #if 0
	motor[liftMotor1] = y;
}//arm
void sirvo ()
{
	getJoystickSettings(joystick);
	if (OPEN)
	{
		servo[servo1] = 255;
	}
	else if (CLOSE)
	{
		servo[servo1] = 0;
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
// 1. Loop forever repeating the following actions:
// 2. Get the latest game controller / joystick settings that have been received from the PC.
// 3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
// simple action:
// * Joystick values are usually directly translated into power levels for a motor or
// position of a servo.
// * Buttons are usually used to start/stop a motor or cause a servo to move to a specific
// position.
// 4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	waitForStart(); // wait for start of tele-op phase

	while (true)
	{
		///////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////
		//// ////
		//// Add your robot specific tele-op code here. ////
		//// ////
		///////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////

		// Insert code to have servos and motors respond to joystick and button values.

		// Look in the ROBOTC samples folder for programs that may be similar to what you want to perform.
		// You may be able to find "snippets" of code that are similar to the functions that you want to
		// perform.
		drive();
		arm();
		sirvo();

	}//While true
}//task main
