#pragma config(Hubs, S1, HTMotor, HTMotor, HTMotor, HTServo)
#pragma config(Sensor, S1, , sensorI2CMuxController)
#pragma config(Sensor, S2, touch, sensorTouch)
#pragma config(Sensor, S3, infared, sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4, touchUp, sensorTouch)
#pragma config(Motor, motorA, , tmotorNXT, openLoop)
#pragma config(Motor, motorB, , tmotorNXT, openLoop)
#pragma config(Motor, motorC, , tmotorNXT, openLoop)
#pragma config(Motor, mtr_S1_C1_1, leftBack, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C1_2, leftFront, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C2_1, rightBack, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C2_2, rightFront, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C3_1, liftMotor1, tmotorTetrix, openLoop)
#pragma config(Servo, srvo_S1_C4_1, servo1, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c" //Include file to "handle" the Bluetooth messages.

// #defines for magical values
#define DIVISOR        1.28
#define DIVISOR_LIFT 5.12
#define MARGIN        4

// this is for defining an expression to bitmask for the arcade and tank buttons
// button 5
#define ARCADE        (joystick.joy1_Buttons & 0b00010000)
// button 6
#define TANK                (joystick.joy1_Buttons & 0b00100000)

#define OPEN (joystick.joy2_Buttons & 0b00010000)

#define CLOSE (joystick.joy2_Buttons & 0b00100000)

//Keep the value a between b and c
#define CONSTRAIN(a, b, c) ( ((a)<(b)) ? (b) : ( ((a)>(c)) ? (c) : (a)) )

#define MAXARM 300

#define MINARM 10

//Variable to track arcade and tank modes
bool tank = true;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
        //these lines make sure the motors are stopped when the robot is turned on
        motor[rightBack] = 0;
        motor[rightFront] = 0;
        motor[leftBack] = 0;
        motor[leftFront] = 0;
        nMotorEncoder[liftMotor1] = 0;
  return;
}


void drive()
{
        // this is to retrieve joystick values
        getJoystickSettings(joystick);
        // these switch between arcade and tank mode
        if (ARCADE)
        {
                tank = false;
        }
        if (TANK)
        {
                tank = true;
        }
        // this is tank setting
        if (tank)
        {
                // translating joystick values from 128 to -127 to motor speeds
                float y1 = (float)(joystick.joy1_y1) / DIVISOR;
                float y2 = -(float)(joystick.joy1_y2) / DIVISOR;
                // wheels will be stopped when desired
                y1 = (abs(y1) - MARGIN < MARGIN) ? 0 : y1;
                y2 = (abs(y2) - MARGIN < MARGIN) ? 0 : y2;
                // sets motors
                motor[leftBack] = y1;
                motor[leftFront] = y1;
                motor[rightBack] = y2;
                motor[rightFront] = y2;
        }
        // this is arcade mode
        else
        {
                //translating joystick values to motor speeds
                float y = (float)(joystick.joy1_y2) / DIVISOR;
                float x = (float)(joystick.joy1_x2) / DIVISOR;
                // wheels are still when desired
                y = (abs(y) - MARGIN < MARGIN) ? 0 : y;
                x = (abs(x) - MARGIN < MARGIN) ? 0 : x;
                // calculating arcade values
                float left = CONSTRAIN(y + x, -128/DIVISOR, 128/DIVISOR);
                float right = -CONSTRAIN(y - x, -128/DIVISOR, 128/DIVISOR);
                // sets motors
                motor[leftBack] = left;
                motor[leftFront] = left;
                motor[rightBack] = right;
                motor[rightFront] = right;
        }

}
        //for the arm
void arm()
{
        // retrieves joystick settings
        getJoystickSettings(joystick);
        //translates joystick values to motor values
        float y = (float) (joystick.joy2_y1) / DIVISOR_LIFT;

        if ( y > 0 )
                {

                if (nMotorEncoder[liftMotor1] > MAXARM)
                        {
                        y = 0;
                        }//maxarm
                }// y>0
        
        if (y < 0 )
        {
                if (nMotorEncoder[liftMotor1] < MINARM)
                {
                y = 0;
                }//minarm
        }//y<0
        motor[liftMotor1] = y;
}//arm
void sirvo ()
{
        getJoystickSettings(joystick);
        if (OPEN)
                {
                servo[servo1] = 255;
                }
        if (CLOSE)
                {
                servo[servo1] = 0;
                }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
// 1. Loop forever repeating the following actions:
// 2. Get the latest game controller / joystick settings that have been received from the PC.
// 3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
// simple action:
// * Joystick values are usually directly translated into power levels for a motor or
// position of a servo.
// * Buttons are usually used to start/stop a motor or cause a servo to move to a specific
// position.
// 4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  //waitForStart(); // wait for start of tele-op phase

  while (true)
  {
         ///////////////////////////////////////////////////////////
         ///////////////////////////////////////////////////////////
         //// ////
         //// Add your robot specific tele-op code here. ////
         //// ////
         ///////////////////////////////////////////////////////////
         ///////////////////////////////////////////////////////////

    // Insert code to have servos and motors respond to joystick and button values.

    // Look in the ROBOTC samples folder for programs that may be similar to what you want to perform.
    // You may be able to find "snippets" of code that are similar to the functions that you want to
    // perform.
          drive();
          arm();
          sirvo();

  }//While true
}//task main
